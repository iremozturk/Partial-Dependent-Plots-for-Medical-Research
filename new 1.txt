import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
#from sklearn.ensemble import RandomForestClassifier
#from sklearn.metrics import accuracy_score
from sklearn.model_selection import train_test_split
from DecisionTree.DecisionTree import plot_partial_dependence, train_decision_tree
from sklearn.impute import SimpleImputer
from pdpbox import pdp

input_file_path = r'C:\\Users\\iremo\\Downloads\\hypothyroid.csv'
output_file = 'C:\\\\Users\\iremo\\PycharmProjects\\pythonProject1\\outputsu.csv'

# Read the CSV file into a DataFrame\n",
df = pd.read_csv(input_file_path)

# Define a list of columns you want to change
# Specify the column you want to delete
column_to_delete = ['TSH', 'T3', 'TT4', 'T4U', 'FTI', 'TBG',
                    'referral source']

# Check if the column exists before deleting it
for column in column_to_delete:
    if column in df.columns:
        df.drop(column, axis=1, inplace=True)

columns_to_convert = ['on thyroxine', 'query on thyroxine', 'on antithyroid medication', 'sick', 'pregnant',
                      'thyroid surgery', 'I131 treatment', 'query hypothyroid', 'query hyperthyroid', 'lithium',
                      'goitre', 'tumor', 'hypopituitary', 'psych', 'TSH measured', 'T3 measured', 'TT4 measured',
                      'T4U measured', 'FTI measured', 'TBG measured']
# Create a mapping dictionary\n",
sex_mapping = {'M': 0, 'F': 1}

# Map the 'sex' column using the mapping dictionary
df['sex'] = df['sex'].map(sex_mapping)

# Loop through the columns and convert values
for column in columns_to_convert:
    df[column] = df[column].map({'f': 0, 't': 1})

# Replace '?' with NaN
df.replace('?', np.nan, inplace=True)

# Initialize SimpleImputer with the strategy I prefer--replace with the mean value
imputer = SimpleImputer(strategy='mean')



# Save the updated DataFrame to a new CSV file\n
df.to_csv(output_file, index=False, sep=',')
print(df.head(10))

#from sklearn.inspection import plot_partial_dependence
# Load your dataset (replace 'your_dataset.csv' with the actual file path)
df = pd.read_csv(r'C:\\\\Users\\iremo\\PycharmProjects\\pythonProject1\\outputsu.csv')
# Select numerical columns and convert to float

numerical_cols = df.select_dtypes(include=[np.number]).columns
df[numerical_cols] = df[numerical_cols].astype(float)

# Calculate mode values for each numerical column
mode_values = df[numerical_cols].mode()

# Iterate through numerical columns and replace non-numeric values with the mode value
for col in numerical_cols:
    mode = mode_values[col].values[0]  # Get the mode value for the column
    df[col] = df[col].apply(lambda x: mode if x == '?' else x)


# Handle other missing values (e.g., replace NaNs with mode)
df.fillna(df.mode(), inplace=True)



# Now,  DataFrame should only contain numeric values or appropriate replacements

# Define target variable (binaryClass in my case)
X = df.drop(columns=['binaryClass'])
y = df['binaryClass']
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
# Fit and transform the data to impute missing values
X_train = imputer.fit_transform(X_train)

decision_tree = train_decision_tree(X_train, y_train)

# Generate and plot Partial Dependence Plots (PDPs)
features_to_plot = ['age', 'TSH measured']
plot_partial_dependence(decision_tree, X_train, features=features_to_plot)



# Generate and plot Partial Dependence Plots (PDPs)
features_to_plot = ['age', 'TSH measured']
# Assuming X_train is a NumPy array, and you have a list of feature names
feature_names = ['age', 'TSH measured', 'sex', 'on thyroxine', 'query on thyroxine', 'on antithyroid medication',
                 'sick', 'pregnant', 'thyroid surgery', 'I131 treatment', 'query hypothyroid', 'query hyperthyroid',
                 'lithium', 'goitre', 'tumor', 'hypopituitary', 'psych', 'TSH measured', 'T3 measured', 'TT4 measured',
                 'T4U measured', 'FTI measured', 'TBG measured', 'binaryClass']  # List all feature names
df = pd.DataFrame(columns=feature_names)
# Create a DataFrame from the NumPy array and specify the columns
X_train_df = pd.DataFrame(X_train, columns=feature_names)

# Now, you can use X_train_df in your pdp.pdp_isolate function
for feature_name in features_to_plot:
    pdp_feature = pdp.pdp_isolate(model=decision_tree, dataset=X_train_df, model_features=feature_names, feature=feature_name)
    pdp.pdp_plot(pdp_feature, feature_name)

